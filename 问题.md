### 缓冲区

使用栅格法处理缓冲区

因为暴力枚举，复杂度$O(n*m)$,n是栅格大小，m是线上的点数

100000个格子，大约有1000的点数，大概一秒内算出来

```cpp
    double area = (bounds.width() + 2 * r) * (bounds.height() + 2 * r);
    gridMap.scale = std::sqrt(area / 100000.0);  // 缩放比例
```

![image-20250111193534201](C:\Users\33797\AppData\Roaming\Typora\typora-user-images\image-20250111193534201.png)



1000000个格子，大概十几秒内算出来

```cpp
    double area = (bounds.width() + 2 * r) * (bounds.height() + 2 * r);
    gridMap.scale = std::sqrt(area / 1000000.0);  // 缩放比例
```

![image-20250111193942499](C:\Users\33797\AppData\Roaming\Typora\typora-user-images\image-20250111193942499.png)

10000000个格子，大概几分钟算出来

```cpp
    double area = (bounds.width() + 2 * r) * (bounds.height() + 2 * r);
    gridMap.scale = std::sqrt(area / 10000000.0);  // 缩放比例
```

![image-20250111195441519](C:\Users\33797\AppData\Roaming\Typora\typora-user-images\image-20250111195441519.png)





稀疏，加条样。

还是会有突起，在直线的附近极为明显。

问题在怎么区分凸起是误差还是趋势。

![image-20250111203527192](C:\Users\33797\AppData\Roaming\Typora\typora-user-images\image-20250111203527192.png)



使用`Douglas-Peucker` 算法，简化线段，想忽略掉误差的凸起，效果不错

![image-20250111213320489](C:\Users\33797\AppData\Roaming\Typora\typora-user-images\image-20250111213320489.png)

再加插值和B样条

![image-20250111215414312](C:\Users\33797\AppData\Roaming\Typora\typora-user-images\image-20250111215414312.png)





又有新的想法，其实可以分块提高精度

